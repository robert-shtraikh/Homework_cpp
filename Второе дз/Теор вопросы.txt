1.	
	1) Пространство ядра ОС
	2)Стек
	3)Свободное пространство
	4)Куча
	5)Сегмент данных
	6)Сегмент кода

2. int v[] = {1, 2, 3, 4}
int* p = v; // указатель на 1 элемент
int* p = &v[0]; // то же самое
int* p_1 = v-1; // error
int* p_2 = v+4; // error
int* p_3 = v+3; // ok

Поэтому если нужно передать массив в функцию void foo(int* arr, size_tsize);
нужно указывать размер массива, а это не очень удобно. Решение: std::vector v; v.size();

3. При разыменовании указателя, программа пытается перейти в ячейку памяти, которая хранится в указателе и извлечь содержимое этой ячейки. 
По соображениям безопасности современные ОС запускают программы в песочнице для предотвращения их неправильного взаимодействия с другими
программами и для защиты стабильности самой операционной системы. Если программа попытается получить доступ к ячейке памяти, не выделенной для неё операционной системой, 
то ОС сразу завершит выполнение этой программы. Поэтому лучше пользоваться высокоуровневыми средствами работой с памятью, такие как контейнеры std::vector и smart pointers.

4. Ссылка — это тип переменной в языке C++, который работает как псевдоним другого объекта или значения. 
	
	Отличия ссылки от указателя:

	1) Указатель может быть переназначен любое количество раз, в то время как ссылка после привязки не может быть перемещена на другую ячейку памяти.
	2) Указатели могут указывать "в никуда" (быть равными NULL), в то время как ссылка всегда указывает на определенный объект. GCC может без выдачи предупреждений обработать код наподобие int &x = *(int*)0;, однако поведение подобного кода может быть непредсказуемым.
	3) Вы не можете получить адрес ссылки, как можете это делать с указателями.
	4) Не существует арифметики ссылок, в то время как существует арифметика указателей. Однако есть возможность получить адрес объекта, указанного по ссылке, и применить к этому адресу арифметику указателей (например &obj + 5).

5. В языке С++ данные в функцию можно передавать тремя способами: по значению, по адресу и по ссылке.

